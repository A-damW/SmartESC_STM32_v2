// This file is autogenerated by VESC Tool

#include "buffer.h"
#include "confgenerator.h"
#include "tune.h"
#include <string.h>
#include "drive_parameters.h"
#include "mc_stm_types.h"

int32_t confgenerator_serialize_mcconf(uint8_t *buffer, const mc_configuration *conf) {
	int32_t ind = 0;

	buffer_append_uint32(buffer, MCCONF_SIGNATURE, &ind);

	buffer[ind++] = conf->pwm_mode;
	buffer[ind++] = conf->comm_mode;
	buffer[ind++] = conf->motor_type;
	buffer[ind++] = conf->sensor_mode;
	buffer_append_float32_auto(buffer, conf->l_current_max, &ind);
	buffer_append_float32_auto(buffer, conf->l_current_min, &ind);
	buffer_append_float32_auto(buffer, conf->l_in_current_max, &ind);
	buffer_append_float32_auto(buffer, conf->l_in_current_min, &ind);
	buffer_append_float32_auto(buffer, conf->l_abs_current_max, &ind);
	buffer_append_float32_auto(buffer, conf->l_min_erpm, &ind);
	buffer_append_float32_auto(buffer, conf->l_max_erpm, &ind);
	buffer_append_float32_auto(buffer, conf->l_erpm_start, &ind);
	buffer_append_float32_auto(buffer, conf->l_max_erpm_fbrake, &ind);
	buffer_append_float32_auto(buffer, conf->l_max_erpm_fbrake_cc, &ind);
	buffer_append_float32_auto(buffer, conf->l_min_vin, &ind);
	buffer_append_float32_auto(buffer, conf->l_max_vin, &ind);
	buffer_append_float32_auto(buffer, conf->l_battery_cut_start, &ind);
	buffer_append_float32_auto(buffer, conf->l_battery_cut_end, &ind);
	buffer[ind++] = conf->l_slow_abs_current;
	buffer_append_float32_auto(buffer, conf->l_temp_fet_start, &ind);
	buffer_append_float32_auto(buffer, conf->l_temp_fet_end, &ind);
	buffer_append_float32_auto(buffer, conf->l_temp_motor_start, &ind);
	buffer_append_float32_auto(buffer, conf->l_temp_motor_end, &ind);
	buffer_append_float32_auto(buffer, conf->l_temp_accel_dec, &ind);
	buffer_append_float32_auto(buffer, conf->l_min_duty, &ind);
	buffer_append_float32_auto(buffer, conf->l_max_duty, &ind);
	buffer_append_float32_auto(buffer, conf->l_watt_max, &ind);
	buffer_append_float32_auto(buffer, conf->l_watt_min, &ind);
	buffer_append_float32_auto(buffer, conf->l_current_max_scale, &ind);
	buffer_append_float32_auto(buffer, conf->l_current_min_scale, &ind);
	buffer_append_float32_auto(buffer, conf->l_duty_start, &ind);
//	buffer_append_float32_auto(buffer, conf->sl_min_erpm, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->sl_min_erpm_cycle_int_limit, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->sl_max_fullbreak_current_dir_change, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->sl_cycle_int_limit, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->sl_phase_advance_at_br, &ind);/
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->sl_cycle_int_rpm_br, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->sl_bemf_coupling_k, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer[ind++] = (uint8_t)conf->hall_table[0];
//	buffer[ind++] = (uint8_t)conf->hall_table[1];
//	buffer[ind++] = (uint8_t)conf->hall_table[2];
//	buffer[ind++] = (uint8_t)conf->hall_table[3];
//	buffer[ind++] = (uint8_t)conf->hall_table[4];
//	buffer[ind++] = (uint8_t)conf->hall_table[5];
//	buffer[ind++] = (uint8_t)conf->hall_table[6];
//	buffer[ind++] = (uint8_t)conf->hall_table[7];
	ind+=8;
//	buffer_append_float32_auto(buffer, conf->hall_sl_erpm, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
	buffer_append_float32_auto(buffer, conf->foc_current_kp, &ind);
	buffer_append_float32_auto(buffer, conf->foc_current_ki, &ind);
	buffer_append_float32_auto(buffer, conf->foc_f_sw, &ind);
	buffer_append_float32_auto(buffer, conf->foc_dt_us, &ind);
//	buffer[ind++] = conf->foc_encoder_inverted;
	buffer[ind++] = 0;
	buffer_append_float32_auto(buffer, conf->foc_encoder_offset, &ind);
//	buffer_append_float32_auto(buffer, conf->foc_encoder_ratio, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->foc_encoder_sin_gain, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->foc_encoder_cos_gain, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->foc_encoder_sin_offset, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->foc_encoder_cos_offset, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->foc_encoder_sincos_filter_constant, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
	buffer[ind++] = conf->foc_sensor_mode;
	buffer_append_float32_auto(buffer, conf->foc_pll_kp, &ind);
	buffer_append_float32_auto(buffer, conf->foc_pll_ki, &ind);
	buffer_append_float32_auto(buffer, conf->foc_motor_l, &ind);
	buffer_append_float32_auto(buffer, conf->foc_motor_ld_lq_diff, &ind);
	buffer_append_float32_auto(buffer, conf->foc_motor_r, &ind);
	buffer_append_float32_auto(buffer, conf->foc_motor_flux_linkage, &ind);
	buffer_append_float32_auto(buffer, conf->foc_observer_gain, &ind);
	buffer_append_float32_auto(buffer, conf->foc_observer_gain_slow, &ind);
	buffer_append_float32_auto(buffer, conf->foc_duty_dowmramp_kp, &ind);
	buffer_append_float32_auto(buffer, conf->foc_duty_dowmramp_ki, &ind);
	buffer_append_float32_auto(buffer, conf->foc_openloop_rpm, &ind);
	buffer_append_float16(buffer, conf->foc_openloop_rpm_low, 1000, &ind);
	buffer_append_float32_auto(buffer, conf->foc_d_gain_scale_start, &ind);
	buffer_append_float32_auto(buffer, conf->foc_d_gain_scale_max_mod, &ind);
	buffer_append_float16(buffer, conf->foc_sl_openloop_hyst, 100, &ind);
	buffer_append_float16(buffer, conf->foc_sl_openloop_time_lock, 100, &ind);
	buffer_append_float16(buffer, conf->foc_sl_openloop_time_ramp, 100, &ind);
	buffer_append_float16(buffer, conf->foc_sl_openloop_time, 100, &ind);
	buffer[ind++] = (uint8_t)conf->foc_hall_table[0];
	buffer[ind++] = (uint8_t)conf->foc_hall_table[1];
	buffer[ind++] = (uint8_t)conf->foc_hall_table[2];
	buffer[ind++] = (uint8_t)conf->foc_hall_table[3];
	buffer[ind++] = (uint8_t)conf->foc_hall_table[4];
	buffer[ind++] = (uint8_t)conf->foc_hall_table[5];
	buffer[ind++] = (uint8_t)conf->foc_hall_table[6];
	buffer[ind++] = (uint8_t)conf->foc_hall_table[7];
	buffer_append_float32_auto(buffer, conf->foc_hall_interp_erpm, &ind);
	buffer_append_float32_auto(buffer, conf->foc_sl_erpm, &ind);
	buffer[ind++] = conf->foc_sample_v0_v7;
	buffer[ind++] = conf->foc_sample_high_current;
	buffer_append_float16(buffer, conf->foc_sat_comp, 1000, &ind);
	buffer[ind++] = conf->foc_temp_comp;
	buffer_append_float16(buffer, conf->foc_temp_comp_base_temp, 100, &ind);
	buffer_append_float32_auto(buffer, conf->foc_current_filter_const, &ind);
	buffer[ind++] = conf->foc_cc_decoupling;
	buffer[ind++] = conf->foc_observer_type;
	//buffer_append_float32_auto(buffer, conf->foc_hfi_voltage_start, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
	//buffer_append_float32_auto(buffer, conf->foc_hfi_voltage_run, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
	//buffer_append_float32_auto(buffer, conf->foc_hfi_voltage_max, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
	//buffer_append_float32_auto(buffer, conf->foc_sl_erpm_hfi, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
	//buffer_append_uint16(buffer, conf->foc_hfi_start_samples, &ind);
	buffer_append_uint16(buffer, 0, &ind);
	//buffer_append_float32_auto(buffer, conf->foc_hfi_obs_ovr_sec, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
	//buffer[ind++] = conf->foc_hfi_samples;
	ind++;

//	buffer_append_int16(buffer, conf->gpd_buffer_notify_left, &ind);
	buffer_append_int16(buffer, 0, &ind);
//	buffer_append_int16(buffer, conf->gpd_buffer_interpol, &ind);
	buffer_append_int16(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->gpd_current_filter_const, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->gpd_current_kp, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->gpd_current_ki, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);

	buffer_append_float32_auto(buffer, conf->s_pid_kp, &ind);
	buffer_append_float32_auto(buffer, conf->s_pid_ki, &ind);
	buffer_append_float32_auto(buffer, conf->s_pid_kd, &ind);
	buffer_append_float32_auto(buffer, conf->s_pid_kd_filter, &ind);
	buffer_append_float32_auto(buffer, conf->s_pid_min_erpm, &ind);
	buffer[ind++] = conf->s_pid_allow_braking;
	buffer_append_float32_auto(buffer, conf->s_pid_ramp_erpms_s, &ind);
//	buffer_append_float32_auto(buffer, conf->p_pid_kp, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->p_pid_ki, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->p_pid_kd, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->p_pid_kd_filter, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
//	buffer_append_float32_auto(buffer, conf->p_pid_ang_div, &ind);
	buffer_append_float32_auto(buffer, 0, &ind);
	buffer_append_float32_auto(buffer, conf->cc_startup_boost_duty, &ind);
	buffer_append_float32_auto(buffer, conf->cc_min_current, &ind);
	buffer_append_float32_auto(buffer, conf->cc_gain, &ind);
	buffer_append_float32_auto(buffer, conf->cc_ramp_step_max, &ind);
	buffer_append_int32(buffer, conf->m_fault_stop_time_ms, &ind);
	buffer_append_float32_auto(buffer, conf->m_duty_ramp_step, &ind);
	buffer_append_float32_auto(buffer, conf->m_current_backoff_gain, &ind);
	buffer_append_uint32(buffer, conf->m_encoder_counts, &ind);
	buffer[ind++] = conf->m_sensor_port_mode;
	buffer[ind++] = conf->m_invert_direction;
	buffer[ind++] = conf->m_drv8301_oc_mode;
	buffer[ind++] = (uint8_t)conf->m_drv8301_oc_adj;
	buffer_append_float32_auto(buffer, conf->m_bldc_f_sw_min, &ind);
	buffer_append_float32_auto(buffer, conf->m_bldc_f_sw_max, &ind);
	buffer_append_float32_auto(buffer, conf->m_dc_f_sw, &ind);
	buffer_append_float32_auto(buffer, conf->m_ntc_motor_beta, &ind);
	buffer[ind++] = conf->m_out_aux_mode;
	buffer[ind++] = conf->m_motor_temp_sens_type;
	buffer_append_float32_auto(buffer, conf->m_ptc_motor_coeff, &ind);
	buffer[ind++] = (uint8_t)conf->m_hall_extra_samples;
	buffer[ind++] = (uint8_t)conf->si_motor_poles;
	buffer_append_float32_auto(buffer, conf->si_gear_ratio, &ind);
	buffer_append_float32_auto(buffer, conf->si_wheel_diameter, &ind);
	buffer[ind++] = conf->si_battery_type;
	buffer[ind++] = (uint8_t)conf->si_battery_cells;
	buffer_append_float32_auto(buffer, conf->si_battery_ah, &ind);
	//buffer[ind++] = conf->bms.type;
	buffer[ind++] = 0;
	//buffer_append_float16(buffer, conf->bms.t_limit_start, 100, &ind);
	buffer_append_float16(buffer, 0, 100, &ind);
	//buffer_append_float16(buffer, conf->bms.t_limit_end, 100, &ind);
	buffer_append_float16(buffer, 0, 100, &ind);
	//buffer_append_float16(buffer, conf->bms.soc_limit_start, 1000, &ind);
	buffer_append_float16(buffer, 0, 1000, &ind);
	//buffer_append_float16(buffer, conf->bms.soc_limit_end, 1000, &ind);
	buffer_append_float16(buffer, 0, 1000, &ind);
	return ind;
}

int32_t confgenerator_serialize_appconf(uint8_t *buffer, const app_configuration *conf) {
	int32_t ind = 0;

	buffer_append_uint32(buffer, APPCONF_SIGNATURE, &ind);

	buffer[ind++] = (uint8_t)conf->controller_id;
	buffer_append_uint32(buffer, conf->timeout_msec, &ind);
	buffer_append_float32_auto(buffer, conf->timeout_brake_current, &ind);
	buffer[ind++] = conf->send_can_status;
	buffer_append_uint16(buffer, conf->send_can_status_rate_hz, &ind);
	buffer[ind++] = conf->can_baud_rate;
	buffer[ind++] = conf->pairing_done;
	buffer[ind++] = conf->permanent_uart_enabled;
	buffer[ind++] = conf->shutdown_mode;
	buffer[ind++] = conf->can_mode;
	buffer[ind++] = (uint8_t)conf->uavcan_esc_index;
	buffer[ind++] = conf->uavcan_raw_mode;
	buffer[ind++] = conf->app_to_use;
	buffer[ind++] = conf->app_ppm_conf.ctrl_type;
	buffer_append_float32_auto(buffer, conf->app_ppm_conf.pid_max_erpm, &ind);
	buffer_append_float32_auto(buffer, conf->app_ppm_conf.hyst, &ind);
	buffer_append_float32_auto(buffer, conf->app_ppm_conf.pulse_start, &ind);
	buffer_append_float32_auto(buffer, conf->app_ppm_conf.pulse_end, &ind);
	buffer_append_float32_auto(buffer, conf->app_ppm_conf.pulse_center, &ind);
	buffer[ind++] = conf->app_ppm_conf.median_filter;
	buffer[ind++] = conf->app_ppm_conf.safe_start;
	buffer_append_float32_auto(buffer, conf->app_ppm_conf.throttle_exp, &ind);
	buffer_append_float32_auto(buffer, conf->app_ppm_conf.throttle_exp_brake, &ind);
	buffer[ind++] = conf->app_ppm_conf.throttle_exp_mode;
	buffer_append_float32_auto(buffer, conf->app_ppm_conf.ramp_time_pos, &ind);
	buffer_append_float32_auto(buffer, conf->app_ppm_conf.ramp_time_neg, &ind);
	buffer[ind++] = conf->app_ppm_conf.multi_esc;
	buffer[ind++] = conf->app_ppm_conf.tc;
	buffer_append_float32_auto(buffer, conf->app_ppm_conf.tc_max_diff, &ind);
	buffer_append_float32_auto(buffer, conf->app_ppm_conf.max_erpm_for_dir, &ind);
	buffer_append_float32_auto(buffer, conf->app_ppm_conf.smart_rev_max_duty, &ind);
	buffer_append_float32_auto(buffer, conf->app_ppm_conf.smart_rev_ramp_time, &ind);
	buffer[ind++] = conf->app_adc_conf.ctrl_type;
	buffer_append_float32_auto(buffer, conf->app_adc_conf.hyst, &ind);
	buffer_append_float32_auto(buffer, conf->app_adc_conf.voltage_start, &ind);
	buffer_append_float32_auto(buffer, conf->app_adc_conf.voltage_end, &ind);
	buffer_append_float32_auto(buffer, conf->app_adc_conf.voltage_center, &ind);
	buffer_append_float32_auto(buffer, conf->app_adc_conf.voltage2_start, &ind);
	buffer_append_float32_auto(buffer, conf->app_adc_conf.voltage2_end, &ind);
	buffer[ind++] = conf->app_adc_conf.use_filter;
	buffer[ind++] = conf->app_adc_conf.safe_start;
	buffer[ind++] = conf->app_adc_conf.cc_button_inverted;
	buffer[ind++] = conf->app_adc_conf.rev_button_inverted;
	buffer[ind++] = conf->app_adc_conf.voltage_inverted;
	buffer[ind++] = conf->app_adc_conf.voltage2_inverted;
	buffer_append_float32_auto(buffer, conf->app_adc_conf.throttle_exp, &ind);
	buffer_append_float32_auto(buffer, conf->app_adc_conf.throttle_exp_brake, &ind);
	buffer[ind++] = conf->app_adc_conf.throttle_exp_mode;
	buffer_append_float32_auto(buffer, conf->app_adc_conf.ramp_time_pos, &ind);
	buffer_append_float32_auto(buffer, conf->app_adc_conf.ramp_time_neg, &ind);
	buffer[ind++] = conf->app_adc_conf.multi_esc;
	buffer[ind++] = conf->app_adc_conf.tc;
	buffer_append_float32_auto(buffer, conf->app_adc_conf.tc_max_diff, &ind);
	buffer_append_uint16(buffer, conf->app_adc_conf.update_rate_hz, &ind);
	buffer_append_uint32(buffer, conf->app_uart_baudrate, &ind);
	buffer[ind++] = conf->app_chuk_conf.ctrl_type;
	buffer_append_float32_auto(buffer, conf->app_chuk_conf.hyst, &ind);
	buffer_append_float32_auto(buffer, conf->app_chuk_conf.ramp_time_pos, &ind);
	buffer_append_float32_auto(buffer, conf->app_chuk_conf.ramp_time_neg, &ind);
	buffer_append_float32_auto(buffer, conf->app_chuk_conf.stick_erpm_per_s_in_cc, &ind);
	buffer_append_float32_auto(buffer, conf->app_chuk_conf.throttle_exp, &ind);
	buffer_append_float32_auto(buffer, conf->app_chuk_conf.throttle_exp_brake, &ind);
	buffer[ind++] = conf->app_chuk_conf.throttle_exp_mode;
	buffer[ind++] = conf->app_chuk_conf.multi_esc;
	buffer[ind++] = conf->app_chuk_conf.tc;
	buffer_append_float32_auto(buffer, conf->app_chuk_conf.tc_max_diff, &ind);
	buffer[ind++] = conf->app_chuk_conf.use_smart_rev;
	buffer_append_float32_auto(buffer, conf->app_chuk_conf.smart_rev_max_duty, &ind);
	buffer_append_float32_auto(buffer, conf->app_chuk_conf.smart_rev_ramp_time, &ind);
	buffer[ind++] = conf->app_nrf_conf.speed;
	buffer[ind++] = conf->app_nrf_conf.power;
	buffer[ind++] = conf->app_nrf_conf.crc_type;
	buffer[ind++] = conf->app_nrf_conf.retry_delay;
	buffer[ind++] = (uint8_t)conf->app_nrf_conf.retries;
	buffer[ind++] = (uint8_t)conf->app_nrf_conf.channel;
	buffer[ind++] = (uint8_t)conf->app_nrf_conf.address[0];
	buffer[ind++] = (uint8_t)conf->app_nrf_conf.address[1];
	buffer[ind++] = (uint8_t)conf->app_nrf_conf.address[2];
	buffer[ind++] = conf->app_nrf_conf.send_crc_ack;
	buffer_append_float32_auto(buffer, conf->app_balance_conf.kp, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.ki, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.kd, &ind);
	buffer_append_uint16(buffer, conf->app_balance_conf.hertz, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.fault_pitch, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.fault_roll, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.fault_duty, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.fault_adc1, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.fault_adc2, &ind);
	buffer_append_uint16(buffer, conf->app_balance_conf.fault_delay_pitch, &ind);
	buffer_append_uint16(buffer, conf->app_balance_conf.fault_delay_roll, &ind);
	buffer_append_uint16(buffer, conf->app_balance_conf.fault_delay_duty, &ind);
	buffer_append_uint16(buffer, conf->app_balance_conf.fault_delay_switch_half, &ind);
	buffer_append_uint16(buffer, conf->app_balance_conf.fault_delay_switch_full, &ind);
	buffer_append_uint16(buffer, conf->app_balance_conf.fault_adc_half_erpm, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.tiltback_angle, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.tiltback_speed, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.tiltback_duty, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.tiltback_high_voltage, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.tiltback_low_voltage, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.tiltback_constant, &ind);
	buffer_append_uint16(buffer, conf->app_balance_conf.tiltback_constant_erpm, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.startup_pitch_tolerance, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.startup_roll_tolerance, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.startup_speed, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.deadzone, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.current_boost, &ind);
	buffer[ind++] = conf->app_balance_conf.multi_esc;
	buffer_append_float32_auto(buffer, conf->app_balance_conf.yaw_kp, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.yaw_ki, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.yaw_kd, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.roll_steer_kp, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.roll_steer_erpm_kp, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.brake_current, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.yaw_current_clamp, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.setpoint_pitch_filter, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.setpoint_target_filter, &ind);
	buffer_append_float32_auto(buffer, conf->app_balance_conf.setpoint_filter_clamp, &ind);
	buffer_append_uint16(buffer, conf->app_balance_conf.kd_pt1_frequency, &ind);
	buffer[ind++] = conf->app_pas_conf.ctrl_type;
	buffer[ind++] = conf->app_pas_conf.sensor_type;
	buffer_append_float16(buffer, conf->app_pas_conf.current_scaling, 1000, &ind);
	buffer_append_float16(buffer, conf->app_pas_conf.pedal_rpm_start, 10, &ind);
	buffer_append_float16(buffer, conf->app_pas_conf.pedal_rpm_end, 10, &ind);
	buffer[ind++] = conf->app_pas_conf.invert_pedal_direction;
	buffer_append_uint16(buffer, conf->app_pas_conf.magnets, &ind);
	buffer[ind++] = conf->app_pas_conf.use_filter;
	buffer_append_float16(buffer, conf->app_pas_conf.ramp_time_pos, 100, &ind);
	buffer_append_float16(buffer, conf->app_pas_conf.ramp_time_neg, 100, &ind);
	buffer_append_uint16(buffer, conf->app_pas_conf.update_rate_hz, &ind);
	buffer[ind++] = conf->imu_conf.type;
	buffer[ind++] = conf->imu_conf.mode;
	buffer_append_uint16(buffer, conf->imu_conf.sample_rate_hz, &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.accel_confidence_decay, &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.mahony_kp, &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.mahony_ki, &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.madgwick_beta, &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.rot_roll, &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.rot_pitch, &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.rot_yaw, &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.accel_offsets[0], &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.accel_offsets[1], &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.accel_offsets[2], &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.gyro_offsets[0], &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.gyro_offsets[1], &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.gyro_offsets[2], &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.gyro_offset_comp_fact[0], &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.gyro_offset_comp_fact[1], &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.gyro_offset_comp_fact[2], &ind);
	buffer_append_float32_auto(buffer, conf->imu_conf.gyro_offset_comp_clamp, &ind);

	return ind;
}

bool confgenerator_deserialize_mcconf(const uint8_t *buffer, mc_configuration *conf) {
	int32_t ind = 0;

	uint32_t signature = buffer_get_uint32(buffer, &ind);
	if (signature != MCCONF_SIGNATURE) {
		return false;
	}

	conf->pwm_mode = buffer[ind++];
	conf->comm_mode = buffer[ind++];
	conf->motor_type = buffer[ind++];
	conf->sensor_mode = buffer[ind++];
	conf->l_current_max = buffer_get_float32_auto(buffer, &ind);
	conf->l_current_min = buffer_get_float32_auto(buffer, &ind);
	conf->l_in_current_max = buffer_get_float32_auto(buffer, &ind);
	conf->l_in_current_min = buffer_get_float32_auto(buffer, &ind);
	conf->l_abs_current_max = buffer_get_float32_auto(buffer, &ind);
	conf->l_min_erpm = buffer_get_float32_auto(buffer, &ind);
	conf->l_max_erpm = buffer_get_float32_auto(buffer, &ind);
	conf->l_erpm_start = buffer_get_float32_auto(buffer, &ind);
	conf->l_max_erpm_fbrake = buffer_get_float32_auto(buffer, &ind);
	conf->l_max_erpm_fbrake_cc = buffer_get_float32_auto(buffer, &ind);
	conf->l_min_vin = buffer_get_float32_auto(buffer, &ind);
	conf->l_max_vin = buffer_get_float32_auto(buffer, &ind);
	conf->l_battery_cut_start = buffer_get_float32_auto(buffer, &ind);
	conf->l_battery_cut_end = buffer_get_float32_auto(buffer, &ind);
	conf->l_slow_abs_current = buffer[ind++];
	conf->l_temp_fet_start = buffer_get_float32_auto(buffer, &ind);
	conf->l_temp_fet_end = buffer_get_float32_auto(buffer, &ind);
	conf->l_temp_motor_start = buffer_get_float32_auto(buffer, &ind);
	conf->l_temp_motor_end = buffer_get_float32_auto(buffer, &ind);
	conf->l_temp_accel_dec = buffer_get_float32_auto(buffer, &ind);
	conf->l_min_duty = buffer_get_float32_auto(buffer, &ind);
	conf->l_max_duty = buffer_get_float32_auto(buffer, &ind);
	conf->l_watt_max = buffer_get_float32_auto(buffer, &ind);
	conf->l_watt_min = buffer_get_float32_auto(buffer, &ind);
	conf->l_current_max_scale = buffer_get_float32_auto(buffer, &ind);
	conf->l_current_min_scale = buffer_get_float32_auto(buffer, &ind);
	conf->l_duty_start = buffer_get_float32_auto(buffer, &ind);
//	conf->sl_min_erpm = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
//	conf->sl_min_erpm_cycle_int_limit = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
//	conf->sl_max_fullbreak_current_dir_change = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
//	conf->sl_cycle_int_limit = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
//	conf->sl_phase_advance_at_br = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
//	conf->sl_cycle_int_rpm_br = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
//	conf->sl_bemf_coupling_k = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
//	conf->hall_table[0] = (int8_t)buffer[ind++];
//	conf->hall_table[1] = (int8_t)buffer[ind++];
//	conf->hall_table[2] = (int8_t)buffer[ind++];
//	conf->hall_table[3] = (int8_t)buffer[ind++];
//	conf->hall_table[4] = (int8_t)buffer[ind++];
//	conf->hall_table[5] = (int8_t)buffer[ind++];
//	conf->hall_table[6] = (int8_t)buffer[ind++];
//	conf->hall_table[7] = (int8_t)buffer[ind++];
	ind+=8;
//	conf->hall_sl_erpm = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
	conf->foc_current_kp = buffer_get_float32_auto(buffer, &ind);
	conf->foc_current_ki = buffer_get_float32_auto(buffer, &ind);
	conf->foc_f_sw = buffer_get_float32_auto(buffer, &ind);
	conf->foc_dt_us = buffer_get_float32_auto(buffer, &ind);
//	conf->foc_encoder_inverted = buffer[ind++];
	ind++;
	conf->foc_encoder_offset = buffer_get_float32_auto(buffer, &ind);
//	conf->foc_encoder_ratio = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
//	conf->foc_encoder_sin_gain = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
//	conf->foc_encoder_cos_gain = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
//	conf->foc_encoder_sin_offset = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
//	conf->foc_encoder_cos_offset = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
//	conf->foc_encoder_sincos_filter_constant = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
	conf->foc_sensor_mode = buffer[ind++];
	conf->foc_pll_kp = buffer_get_float32_auto(buffer, &ind);
	conf->foc_pll_ki = buffer_get_float32_auto(buffer, &ind);
	conf->foc_motor_l = buffer_get_float32_auto(buffer, &ind);
	conf->foc_motor_ld_lq_diff = buffer_get_float32_auto(buffer, &ind);
	conf->foc_motor_r = buffer_get_float32_auto(buffer, &ind);
	conf->foc_motor_flux_linkage = buffer_get_float32_auto(buffer, &ind);
	conf->foc_observer_gain = buffer_get_float32_auto(buffer, &ind);
	conf->foc_observer_gain_slow = buffer_get_float32_auto(buffer, &ind);
	conf->foc_duty_dowmramp_kp = buffer_get_float32_auto(buffer, &ind);
	conf->foc_duty_dowmramp_ki = buffer_get_float32_auto(buffer, &ind);
	conf->foc_openloop_rpm = buffer_get_float32_auto(buffer, &ind);
	conf->foc_openloop_rpm_low = buffer_get_float16(buffer, 1000, &ind);
	conf->foc_d_gain_scale_start = buffer_get_float32_auto(buffer, &ind);
	conf->foc_d_gain_scale_max_mod = buffer_get_float32_auto(buffer, &ind);
	conf->foc_sl_openloop_hyst = buffer_get_float16(buffer, 100, &ind);
	conf->foc_sl_openloop_time_lock = buffer_get_float16(buffer, 100, &ind);
	conf->foc_sl_openloop_time_ramp = buffer_get_float16(buffer, 100, &ind);
	conf->foc_sl_openloop_time = buffer_get_float16(buffer, 100, &ind);
	conf->foc_hall_table[0] = buffer[ind++];
	conf->foc_hall_table[1] = buffer[ind++];
	conf->foc_hall_table[2] = buffer[ind++];
	conf->foc_hall_table[3] = buffer[ind++];
	conf->foc_hall_table[4] = buffer[ind++];
	conf->foc_hall_table[5] = buffer[ind++];
	conf->foc_hall_table[6] = buffer[ind++];
	conf->foc_hall_table[7] = buffer[ind++];
	conf->foc_hall_interp_erpm = buffer_get_float32_auto(buffer, &ind);
	conf->foc_sl_erpm = buffer_get_float32_auto(buffer, &ind);
	conf->foc_sample_v0_v7 = buffer[ind++];
	conf->foc_sample_high_current = buffer[ind++];
	conf->foc_sat_comp = buffer_get_float16(buffer, 1000, &ind);
	conf->foc_temp_comp = buffer[ind++];
	conf->foc_temp_comp_base_temp = buffer_get_float16(buffer, 100, &ind);
	conf->foc_current_filter_const = buffer_get_float32_auto(buffer, &ind);
	conf->foc_cc_decoupling = buffer[ind++];
	conf->foc_observer_type = buffer[ind++];
	//conf->foc_hfi_voltage_start = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
	//conf->foc_hfi_voltage_run = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
	//conf->foc_hfi_voltage_max = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
	//conf->foc_sl_erpm_hfi = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
	//conf->foc_hfi_start_samples = buffer_get_uint16(buffer, &ind);
	buffer_get_uint16(buffer, &ind);
	//conf->foc_hfi_obs_ovr_sec = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
	//conf->foc_hfi_samples = buffer[ind++];
	ind++;

	//conf->gpd_buffer_notify_left = buffer_get_int16(buffer, &ind);
	buffer_get_int16(buffer, &ind);
	//conf->gpd_buffer_interpol = buffer_get_int16(buffer, &ind);
	buffer_get_int16(buffer, &ind);
	//conf->gpd_current_filter_const = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
	//conf->gpd_current_kp = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
	//conf->gpd_current_ki = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);

	conf->s_pid_kp = buffer_get_float32_auto(buffer, &ind);
	conf->s_pid_ki = buffer_get_float32_auto(buffer, &ind);
	conf->s_pid_kd = buffer_get_float32_auto(buffer, &ind);
	conf->s_pid_kd_filter = buffer_get_float32_auto(buffer, &ind);
	conf->s_pid_min_erpm = buffer_get_float32_auto(buffer, &ind);
	conf->s_pid_allow_braking = buffer[ind++];
	conf->s_pid_ramp_erpms_s = buffer_get_float32_auto(buffer, &ind);
//	conf->p_pid_kp = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
//	conf->p_pid_ki = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
//	conf->p_pid_kd = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
//	conf->p_pid_kd_filter = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
//	conf->p_pid_ang_div = buffer_get_float32_auto(buffer, &ind);
	buffer_get_float32_auto(buffer, &ind);
	conf->cc_startup_boost_duty = buffer_get_float32_auto(buffer, &ind);
	conf->cc_min_current = buffer_get_float32_auto(buffer, &ind);
	conf->cc_gain = buffer_get_float32_auto(buffer, &ind);
	conf->cc_ramp_step_max = buffer_get_float32_auto(buffer, &ind);
	conf->m_fault_stop_time_ms = buffer_get_int32(buffer, &ind);
	conf->m_duty_ramp_step = buffer_get_float32_auto(buffer, &ind);
	conf->m_current_backoff_gain = buffer_get_float32_auto(buffer, &ind);
	conf->m_encoder_counts = buffer_get_uint32(buffer, &ind);
	conf->m_sensor_port_mode = buffer[ind++];
	conf->m_invert_direction = buffer[ind++];
	conf->m_drv8301_oc_mode = buffer[ind++];
	conf->m_drv8301_oc_adj = buffer[ind++];
	conf->m_bldc_f_sw_min = buffer_get_float32_auto(buffer, &ind);
	conf->m_bldc_f_sw_max = buffer_get_float32_auto(buffer, &ind);
	conf->m_dc_f_sw = buffer_get_float32_auto(buffer, &ind);
	conf->m_ntc_motor_beta = buffer_get_float32_auto(buffer, &ind);
	conf->m_out_aux_mode = buffer[ind++];
	conf->m_motor_temp_sens_type = buffer[ind++];
	conf->m_ptc_motor_coeff = buffer_get_float32_auto(buffer, &ind);
	conf->m_hall_extra_samples = buffer[ind++];
	conf->si_motor_poles = buffer[ind++];
	conf->si_gear_ratio = buffer_get_float32_auto(buffer, &ind);
	conf->si_wheel_diameter = buffer_get_float32_auto(buffer, &ind);
	conf->si_battery_type = buffer[ind++];
	conf->si_battery_cells = buffer[ind++];
	conf->si_battery_ah = buffer_get_float32_auto(buffer, &ind);
	//conf->bms.type = buffer[ind++];
	ind++;
	//conf->bms.t_limit_start = buffer_get_float16(buffer, 100, &ind);
	buffer_get_float16(buffer, 100, &ind);
	//conf->bms.t_limit_end = buffer_get_float16(buffer, 100, &ind);
	buffer_get_float16(buffer, 100, &ind);
	//conf->bms.soc_limit_start = buffer_get_float16(buffer, 1000, &ind);
	buffer_get_float16(buffer, 1000, &ind);
	//conf->bms.soc_limit_end = buffer_get_float16(buffer, 1000, &ind);
	buffer_get_float16(buffer, 1000, &ind);

	return true;
}

bool confgenerator_deserialize_appconf(const uint8_t *buffer, app_configuration *conf) {
	int32_t ind = 0;

	uint32_t signature = buffer_get_uint32(buffer, &ind);
	if (signature != APPCONF_SIGNATURE) {
		return false;
	}

	conf->controller_id = buffer[ind++];
	conf->timeout_msec = buffer_get_uint32(buffer, &ind);
	conf->timeout_brake_current = buffer_get_float32_auto(buffer, &ind);
	conf->send_can_status = buffer[ind++];
	conf->send_can_status_rate_hz = buffer_get_uint16(buffer, &ind);
	conf->can_baud_rate = buffer[ind++];
	conf->pairing_done = buffer[ind++];
	conf->permanent_uart_enabled = buffer[ind++];
	conf->shutdown_mode = buffer[ind++];
	conf->can_mode = buffer[ind++];
	conf->uavcan_esc_index = buffer[ind++];
	conf->uavcan_raw_mode = buffer[ind++];
	conf->app_to_use = buffer[ind++];
	conf->app_ppm_conf.ctrl_type = buffer[ind++];
	conf->app_ppm_conf.pid_max_erpm = buffer_get_float32_auto(buffer, &ind);
	conf->app_ppm_conf.hyst = buffer_get_float32_auto(buffer, &ind);
	conf->app_ppm_conf.pulse_start = buffer_get_float32_auto(buffer, &ind);
	conf->app_ppm_conf.pulse_end = buffer_get_float32_auto(buffer, &ind);
	conf->app_ppm_conf.pulse_center = buffer_get_float32_auto(buffer, &ind);
	conf->app_ppm_conf.median_filter = buffer[ind++];
	conf->app_ppm_conf.safe_start = buffer[ind++];
	conf->app_ppm_conf.throttle_exp = buffer_get_float32_auto(buffer, &ind);
	conf->app_ppm_conf.throttle_exp_brake = buffer_get_float32_auto(buffer, &ind);
	conf->app_ppm_conf.throttle_exp_mode = buffer[ind++];
	conf->app_ppm_conf.ramp_time_pos = buffer_get_float32_auto(buffer, &ind);
	conf->app_ppm_conf.ramp_time_neg = buffer_get_float32_auto(buffer, &ind);
	conf->app_ppm_conf.multi_esc = buffer[ind++];
	conf->app_ppm_conf.tc = buffer[ind++];
	conf->app_ppm_conf.tc_max_diff = buffer_get_float32_auto(buffer, &ind);
	conf->app_ppm_conf.max_erpm_for_dir = buffer_get_float32_auto(buffer, &ind);
	conf->app_ppm_conf.smart_rev_max_duty = buffer_get_float32_auto(buffer, &ind);
	conf->app_ppm_conf.smart_rev_ramp_time = buffer_get_float32_auto(buffer, &ind);
	conf->app_adc_conf.ctrl_type = buffer[ind++];
	conf->app_adc_conf.hyst = buffer_get_float32_auto(buffer, &ind);
	conf->app_adc_conf.voltage_start = buffer_get_float32_auto(buffer, &ind);
	conf->app_adc_conf.voltage_end = buffer_get_float32_auto(buffer, &ind);
	conf->app_adc_conf.voltage_center = buffer_get_float32_auto(buffer, &ind);
	conf->app_adc_conf.voltage2_start = buffer_get_float32_auto(buffer, &ind);
	conf->app_adc_conf.voltage2_end = buffer_get_float32_auto(buffer, &ind);
	conf->app_adc_conf.use_filter = buffer[ind++];
	conf->app_adc_conf.safe_start = buffer[ind++];
	conf->app_adc_conf.cc_button_inverted = buffer[ind++];
	conf->app_adc_conf.rev_button_inverted = buffer[ind++];
	conf->app_adc_conf.voltage_inverted = buffer[ind++];
	conf->app_adc_conf.voltage2_inverted = buffer[ind++];
	conf->app_adc_conf.throttle_exp = buffer_get_float32_auto(buffer, &ind);
	conf->app_adc_conf.throttle_exp_brake = buffer_get_float32_auto(buffer, &ind);
	conf->app_adc_conf.throttle_exp_mode = buffer[ind++];
	conf->app_adc_conf.ramp_time_pos = buffer_get_float32_auto(buffer, &ind);
	conf->app_adc_conf.ramp_time_neg = buffer_get_float32_auto(buffer, &ind);
	conf->app_adc_conf.multi_esc = buffer[ind++];
	conf->app_adc_conf.tc = buffer[ind++];
	conf->app_adc_conf.tc_max_diff = buffer_get_float32_auto(buffer, &ind);
	conf->app_adc_conf.update_rate_hz = buffer_get_uint16(buffer, &ind);
	conf->app_uart_baudrate = buffer_get_uint32(buffer, &ind);
	conf->app_chuk_conf.ctrl_type = buffer[ind++];
	conf->app_chuk_conf.hyst = buffer_get_float32_auto(buffer, &ind);
	conf->app_chuk_conf.ramp_time_pos = buffer_get_float32_auto(buffer, &ind);
	conf->app_chuk_conf.ramp_time_neg = buffer_get_float32_auto(buffer, &ind);
	conf->app_chuk_conf.stick_erpm_per_s_in_cc = buffer_get_float32_auto(buffer, &ind);
	conf->app_chuk_conf.throttle_exp = buffer_get_float32_auto(buffer, &ind);
	conf->app_chuk_conf.throttle_exp_brake = buffer_get_float32_auto(buffer, &ind);
	conf->app_chuk_conf.throttle_exp_mode = buffer[ind++];
	conf->app_chuk_conf.multi_esc = buffer[ind++];
	conf->app_chuk_conf.tc = buffer[ind++];
	conf->app_chuk_conf.tc_max_diff = buffer_get_float32_auto(buffer, &ind);
	conf->app_chuk_conf.use_smart_rev = buffer[ind++];
	conf->app_chuk_conf.smart_rev_max_duty = buffer_get_float32_auto(buffer, &ind);
	conf->app_chuk_conf.smart_rev_ramp_time = buffer_get_float32_auto(buffer, &ind);
	conf->app_nrf_conf.speed = buffer[ind++];
	conf->app_nrf_conf.power = buffer[ind++];
	conf->app_nrf_conf.crc_type = buffer[ind++];
	conf->app_nrf_conf.retry_delay = buffer[ind++];
	conf->app_nrf_conf.retries = (int8_t)buffer[ind++];
	conf->app_nrf_conf.channel = (int8_t)buffer[ind++];
	conf->app_nrf_conf.address[0] = buffer[ind++];
	conf->app_nrf_conf.address[1] = buffer[ind++];
	conf->app_nrf_conf.address[2] = buffer[ind++];
	conf->app_nrf_conf.send_crc_ack = buffer[ind++];
	conf->app_balance_conf.kp = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.ki = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.kd = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.hertz = buffer_get_uint16(buffer, &ind);
	conf->app_balance_conf.fault_pitch = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.fault_roll = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.fault_duty = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.fault_adc1 = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.fault_adc2 = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.fault_delay_pitch = buffer_get_uint16(buffer, &ind);
	conf->app_balance_conf.fault_delay_roll = buffer_get_uint16(buffer, &ind);
	conf->app_balance_conf.fault_delay_duty = buffer_get_uint16(buffer, &ind);
	conf->app_balance_conf.fault_delay_switch_half = buffer_get_uint16(buffer, &ind);
	conf->app_balance_conf.fault_delay_switch_full = buffer_get_uint16(buffer, &ind);
	conf->app_balance_conf.fault_adc_half_erpm = buffer_get_uint16(buffer, &ind);
	conf->app_balance_conf.tiltback_angle = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.tiltback_speed = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.tiltback_duty = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.tiltback_high_voltage = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.tiltback_low_voltage = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.tiltback_constant = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.tiltback_constant_erpm = buffer_get_uint16(buffer, &ind);
	conf->app_balance_conf.startup_pitch_tolerance = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.startup_roll_tolerance = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.startup_speed = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.deadzone = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.current_boost = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.multi_esc = buffer[ind++];
	conf->app_balance_conf.yaw_kp = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.yaw_ki = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.yaw_kd = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.roll_steer_kp = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.roll_steer_erpm_kp = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.brake_current = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.yaw_current_clamp = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.setpoint_pitch_filter = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.setpoint_target_filter = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.setpoint_filter_clamp = buffer_get_float32_auto(buffer, &ind);
	conf->app_balance_conf.kd_pt1_frequency = buffer_get_uint16(buffer, &ind);
	conf->app_pas_conf.ctrl_type = buffer[ind++];
	conf->app_pas_conf.sensor_type = buffer[ind++];
	conf->app_pas_conf.current_scaling = buffer_get_float16(buffer, 1000, &ind);
	conf->app_pas_conf.pedal_rpm_start = buffer_get_float16(buffer, 10, &ind);
	conf->app_pas_conf.pedal_rpm_end = buffer_get_float16(buffer, 10, &ind);
	conf->app_pas_conf.invert_pedal_direction = buffer[ind++];
	conf->app_pas_conf.magnets = buffer_get_uint16(buffer, &ind);
	conf->app_pas_conf.use_filter = buffer[ind++];
	conf->app_pas_conf.ramp_time_pos = buffer_get_float16(buffer, 100, &ind);
	conf->app_pas_conf.ramp_time_neg = buffer_get_float16(buffer, 100, &ind);
	conf->app_pas_conf.update_rate_hz = buffer_get_uint16(buffer, &ind);
	conf->imu_conf.type = buffer[ind++];
	conf->imu_conf.mode = buffer[ind++];
	conf->imu_conf.sample_rate_hz = buffer_get_uint16(buffer, &ind);
	conf->imu_conf.accel_confidence_decay = buffer_get_float32_auto(buffer, &ind);
	conf->imu_conf.mahony_kp = buffer_get_float32_auto(buffer, &ind);
	conf->imu_conf.mahony_ki = buffer_get_float32_auto(buffer, &ind);
	conf->imu_conf.madgwick_beta = buffer_get_float32_auto(buffer, &ind);
	conf->imu_conf.rot_roll = buffer_get_float32_auto(buffer, &ind);
	conf->imu_conf.rot_pitch = buffer_get_float32_auto(buffer, &ind);
	conf->imu_conf.rot_yaw = buffer_get_float32_auto(buffer, &ind);
	conf->imu_conf.accel_offsets[0] = buffer_get_float32_auto(buffer, &ind);
	conf->imu_conf.accel_offsets[1] = buffer_get_float32_auto(buffer, &ind);
	conf->imu_conf.accel_offsets[2] = buffer_get_float32_auto(buffer, &ind);
	conf->imu_conf.gyro_offsets[0] = buffer_get_float32_auto(buffer, &ind);
	conf->imu_conf.gyro_offsets[1] = buffer_get_float32_auto(buffer, &ind);
	conf->imu_conf.gyro_offsets[2] = buffer_get_float32_auto(buffer, &ind);
	conf->imu_conf.gyro_offset_comp_fact[0] = buffer_get_float32_auto(buffer, &ind);
	conf->imu_conf.gyro_offset_comp_fact[1] = buffer_get_float32_auto(buffer, &ind);
	conf->imu_conf.gyro_offset_comp_fact[2] = buffer_get_float32_auto(buffer, &ind);
	conf->imu_conf.gyro_offset_comp_clamp = buffer_get_float32_auto(buffer, &ind);

	return true;
}

const uint8_t hall_def[8] = {255, 214, 40, 253, 123, 167, 85, 255};

void confgenerator_set_defaults_mcconf(mc_configuration *mcconf) {
	memset(mcconf,0,sizeof(mc_configuration));
	// Limits
		mcconf->l_current_max = 10;
		mcconf->l_current_min  = -10;
//		float l_in_current_max;
//		float l_in_current_min;
		mcconf->l_abs_current_max = 60;
		mcconf->l_min_erpm = -35000;
		mcconf->l_max_erpm = 35000;
//		float l_erpm_start;
//		float l_max_erpm_fbrake;
//		float l_max_erpm_fbrake_cc;
		mcconf->l_min_vin = 10;
		mcconf->l_max_vin = 56;
		mcconf->l_battery_cut_end = 31;
		mcconf->l_battery_cut_start = 34;
//		bool l_slow_abs_current;
//		float l_temp_fet_start;
//		float l_temp_fet_end;
//		float l_temp_motor_start;
//		float l_temp_motor_end;
//		float l_temp_accel_dec;
//		float l_min_duty;
//		float l_max_duty;
//		float l_watt_max;
//		float l_watt_min;
//		float l_current_max_scale;
//		float l_current_min_scale;
//		float l_duty_start;
//		// Overridden limits (Computed during runtime)
//		float lo_current_max;
//		float lo_current_min;
//		float lo_in_current_max;
//		float lo_in_current_min;
//		float lo_current_motor_max_now;
//		float lo_current_motor_min_now;


	// BLDC switching and drive
	mcconf->motor_type = MOTOR_TYPE_FOC;
	mcconf->sensor_mode = SENSOR_MODE_SENSORED;
	mcconf->pwm_mode = PWM_MODE_SYNCHRONOUS;

	// FOC
	mcconf->foc_current_kp = 5;
    mcconf->foc_current_ki = 3;
    mcconf->foc_f_sw = 16000;
//	float foc_dt_us;
    mcconf->foc_encoder_offset = 90;
//	bool foc_encoder_inverted;
//	float foc_encoder_ratio;
//	float foc_encoder_sin_offset;
//	float foc_encoder_sin_gain;
//	float foc_encoder_cos_offset;
//	float foc_encoder_cos_gain;
//	float foc_encoder_sincos_filter_constant;
//	float foc_motor_l;
//	float foc_motor_ld_lq_diff;
//	float foc_motor_r;
//	float foc_motor_flux_linkage;
//	float foc_observer_gain;
//	float foc_observer_gain_slow;
//	float foc_pll_kp;
//	float foc_pll_ki;
//	float foc_duty_dowmramp_kp;
//	float foc_duty_dowmramp_ki;
//	float foc_openloop_rpm;
//	float foc_openloop_rpm_low;
//	float foc_d_gain_scale_start;
//	float foc_d_gain_scale_max_mod;
//	float foc_sl_openloop_hyst;
//	float foc_sl_openloop_time;
//	float foc_sl_openloop_time_lock;
//	float foc_sl_openloop_time_ramp;
	mcconf->foc_sensor_mode = FOC_SENSOR_MODE_HALL;

	for(int i=0;i<8;i++){
		mcconf->foc_hall_table[i] = hall_def[i];
	}
	mcconf->foc_hall_interp_erpm = 100;
//	float foc_sl_erpm;
//	bool foc_sample_v0_v7;
//	bool foc_sample_high_current;
//	float foc_sat_comp;
//	bool foc_temp_comp;
//	float foc_temp_comp_base_temp;
//	float foc_current_filter_const;
//	mc_foc_cc_decoupling_mode foc_cc_decoupling;
//	mc_foc_observer_type foc_observer_type;
//	float foc_hfi_voltage_start;
//	float foc_hfi_voltage_run;
//	float foc_hfi_voltage_max;
//	float foc_sl_erpm_hfi;
//	uint16_t foc_hfi_start_samples;
//	float foc_hfi_obs_ovr_sec;
//	uint8_t foc_hfi_samples;

	// GPDrive
//	int gpd_buffer_notify_left;
//	int gpd_buffer_interpol;
//	float gpd_current_filter_const;
//	float gpd_current_kp;
//	float gpd_current_ki;

	// Speed PID
	mcconf->s_pid_kp = (PID_SPEED_KP_DEFAULT)/100.0;
	mcconf->s_pid_ki = (PID_SPEED_KI_DEFAULT)/100.0;
	mcconf->s_pid_kd = (PID_SPEED_KD_DEFAULT)/100.0;
//	float s_pid_kd_filter;
//	float s_pid_min_erpm;
	mcconf->s_pid_allow_braking = false;
	mcconf->s_pid_ramp_erpms_s = 0;

	// Pos PID
//	float p_pid_kp;
//	float p_pid_ki;
//	float p_pid_kd;
//	float p_pid_kd_filter;
//	float p_pid_ang_div;

	// Current controller
//	float cc_startup_boost_duty;
//	float cc_min_current;
//	float cc_gain;
//	float cc_ramp_step_max;

	// Misc
//	int32_t m_fault_stop_time_ms;
//	float m_duty_ramp_step;
//	float m_current_backoff_gain;
//	uint32_t m_encoder_counts;
//	sensor_port_mode m_sensor_port_mode;
//	bool m_invert_direction;
//	drv8301_oc_mode m_drv8301_oc_mode;
//	int m_drv8301_oc_adj;
//	float m_bldc_f_sw_min;
//	float m_bldc_f_sw_max;
//	float m_dc_f_sw;
//	float m_ntc_motor_beta;
//	out_aux_mode m_out_aux_mode;
//	temp_sensor_type m_motor_temp_sens_type;
//	float m_ptc_motor_coeff;
//	int m_hall_extra_samples;

	// Setup info
	mcconf->si_motor_poles = 15;

	mcconf->si_gear_ratio = 1;
	mcconf->si_wheel_diameter = 0.250;
	mcconf->si_battery_type = BATTERY_TYPE_LIION_3_0__4_2;
	mcconf->si_battery_cells = 10;
	mcconf->si_battery_ah = 10;

	// BMS Configuration
//	bms_config bms;

}
